# generated by datamodel-codegen:
#   filename:  async.schema.json

from __future__ import annotations

from enum import Enum
from typing import Any

from libspec.models.base import ExtensionModel
from pydantic import Field, RootModel, conint


class AsyncExtension(RootModel[Any]):
    root: Any = Field(
        ...,
        description='Extension for async/concurrent system semantics: lifecycle, cancellation, synchronization, observables.',
        title='Async Extension',
    )


class Mode(Enum):
    cooperative = 'cooperative'
    immediate = 'immediate'
    none = 'none'


class CancellationSpec(ExtensionModel):
    mode: Mode | None = Field(None, description='Cancellation mode')
    cleanup: str | None = Field(
        None, description='What cleanup happens on cancellation'
    )
    propagates: bool | None = Field(
        True, description='Whether cancellation propagates to children'
    )


class StateSpec(ExtensionModel):
    name: str = Field(..., description='State name')
    description: str | None = Field(None, description='What this state represents')
    terminal: bool | None = Field(False, description='Whether this is a terminal state')
    on_enter: str | None = Field(
        None, description='Action to run on entering this state'
    )
    on_exit: str | None = Field(None, description='Action to run on exiting this state')


class TransitionSpec(ExtensionModel):
    from_: str = Field(..., alias='from', description='Source state name')
    to: str = Field(..., description='Target state name')
    trigger: str = Field(
        ..., description='What causes this transition (method call, event, etc.)'
    )
    guard: str | None = Field(
        None, description='Condition that must be true for transition'
    )
    side_effects: list[str] | None = Field(
        None, description='Side effects of this transition'
    )


class Primitive(Enum):
    mailbox = 'mailbox'
    channel = 'channel'
    lock = 'lock'
    semaphore = 'semaphore'
    event = 'event'
    barrier = 'barrier'
    condition = 'condition'


class Semantics(Enum):
    fifo = 'fifo'
    priority = 'priority'
    broadcast = 'broadcast'
    lifo = 'lifo'


class Backpressure(Enum):
    block = 'block'
    drop = 'drop'
    error = 'error'


class SyncSpec(ExtensionModel):
    primitive: Primitive | None = Field(
        None, description='Type of synchronization primitive'
    )
    semantics: Semantics | None = Field(None, description='Ordering/delivery semantics')
    bounded: bool | None = Field(
        None, description='Whether the primitive has a capacity limit'
    )
    capacity: conint(ge=0) | None = Field(
        None, description='Maximum capacity (if bounded)'
    )
    backpressure: Backpressure | None = Field(
        None, description='What happens when capacity is reached'
    )


class Kind(Enum):
    hot = 'hot'
    cold = 'cold'


class Backpressure1(Enum):
    buffer = 'buffer'
    drop = 'drop'
    block = 'block'
    error = 'error'
    latest = 'latest'


class ObservableSpec(ExtensionModel):
    kind: Kind | None = Field(
        None, description='Hot (live) or cold (replay) observable'
    )
    backpressure: Backpressure1 | None = Field(
        None, description='Backpressure strategy'
    )
    replay: bool | None = Field(
        None, description='Whether late subscribers receive past events'
    )
    replay_buffer: conint(ge=0) | None = Field(
        None, description='Number of past events to replay'
    )
    multicasting: bool | None = Field(
        None, description='Whether multiple subscribers share the same stream'
    )


class Executor(Enum):
    event_loop = 'event_loop'
    thread_pool = 'thread_pool'
    process_pool = 'process_pool'
    custom = 'custom'


class Priority(Enum):
    low = 'low'
    normal = 'normal'
    high = 'high'
    realtime = 'realtime'


class SchedulingSpec(ExtensionModel):
    executor: Executor | None = Field(None, description='Where this runs')
    priority: Priority | None = Field(None, description='Scheduling priority')
    preemptible: bool | None = Field(
        None, description='Whether execution can be preempted'
    )
    timeout_default: float | None = Field(
        None, description='Default timeout in seconds'
    )


class AsyncMethodFields(ExtensionModel):
    async_: bool | None = Field(
        False, alias='async', description='Whether this is an async method'
    )
    awaitable: bool | None = Field(
        None, description='Whether the return value is awaitable'
    )
    blocking: bool | None = Field(
        None, description='Whether this method blocks the event loop'
    )
    cancellation: CancellationSpec | None = None


class AsyncFunctionFields(ExtensionModel):
    async_: bool | None = Field(
        False, alias='async', description='Whether this is an async function'
    )
    awaitable: bool | None = Field(
        None, description='Whether the return value is awaitable'
    )
    blocking: bool | None = Field(
        None, description='Whether this function blocks the event loop'
    )
    cancellation: CancellationSpec | None = None


class LifecycleSpec(ExtensionModel):
    states: list[StateSpec] | None = Field(None, description='All possible states')
    initial_state: str | None = Field(None, description='Initial state name')
    transitions: list[TransitionSpec] | None = Field(
        None, description='Valid state transitions'
    )


class AsyncTypeFields(ExtensionModel):
    lifecycle: LifecycleSpec | None = None
    synchronization: SyncSpec | None = None
    observable: ObservableSpec | None = None
    scheduling: SchedulingSpec | None = None

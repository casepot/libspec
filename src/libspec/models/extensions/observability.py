# generated by datamodel-codegen:
#   filename:  observability.schema.json

from __future__ import annotations

from enum import Enum
from typing import Any

from libspec.models.base import ExtensionModel
from pydantic import Field, RootModel, confloat, conint


class ObservabilityExtension(RootModel[Any]):
    root: Any = Field(
        ...,
        description='Extension for debugging and monitoring: logging, metrics, tracing, health checks.',
        title='Observability Extension',
    )


class LevelsUsedEnum(Enum):
    DEBUG = 'DEBUG'
    INFO = 'INFO'
    WARNING = 'WARNING'
    ERROR = 'ERROR'
    CRITICAL = 'CRITICAL'


class LoggingSpec(ExtensionModel):
    logger_name: str | None = Field(None, description="Logger name (e.g., 'mylib')")
    levels_used: list[LevelsUsedEnum] | None = Field(
        None, description='Log levels used'
    )
    structured: bool | None = Field(
        None, description='Whether structured logging is used'
    )
    context_fields: list[str] | None = Field(
        None, description='Context fields included in log entries'
    )
    sensitive_fields: list[str] | None = Field(
        None, description='Fields that are masked in logs'
    )
    rate_limiting: bool | None = Field(
        None, description='Whether log rate limiting is supported'
    )
    sampling: bool | None = Field(None, description='Whether log sampling is supported')


class Type(Enum):
    counter = 'counter'
    gauge = 'gauge'
    histogram = 'histogram'
    summary = 'summary'
    info = 'info'


class MetricSpec(ExtensionModel):
    name: str = Field(..., description="Metric name (e.g., 'mylib_requests_total')")
    type: Type = Field(..., description='Metric type')
    description: str | None = Field(None, description='What this metric measures')
    labels: list[str] | None = Field(None, description='Label names for this metric')
    unit: str | None = Field(
        None, description="Unit of measurement (e.g., 'seconds', 'bytes')"
    )
    buckets: list[float] | None = Field(
        None, description='Histogram buckets (for histogram type)'
    )


class Propagation(Enum):
    w3c = 'w3c'
    b3 = 'b3'
    jaeger = 'jaeger'
    xray = 'xray'
    datadog = 'datadog'
    custom = 'custom'


class Sampling(Enum):
    always = 'always'
    never = 'never'
    probabilistic = 'probabilistic'
    rate_limited = 'rate_limited'
    parent_based = 'parent_based'


class TracingSpec(ExtensionModel):
    span_names: list[str] | None = Field(None, description='Span names used')
    propagation: Propagation | None = Field(
        None, description='Context propagation format'
    )
    sampling: Sampling | None = Field(None, description='Sampling strategy')
    sampling_rate: confloat(ge=0.0, le=1.0) | None = Field(
        None, description='Sampling rate (0.0-1.0)'
    )
    attributes: list[str] | None = Field(None, description='Standard span attributes')
    events: list[str] | None = Field(None, description='Span events emitted')
    baggage: list[str] | None = Field(None, description='Baggage items propagated')


class Type1(Enum):
    liveness = 'liveness'
    readiness = 'readiness'
    startup = 'startup'


class HealthCheckSpec(ExtensionModel):
    name: str = Field(..., description='Health check name')
    type: Type1 = Field(..., description='Health check type')
    endpoint: str | None = Field(None, description='HTTP endpoint path')
    method: str | None = Field(None, description='Method to call for health check')
    timeout: float | None = Field(None, description='Timeout in seconds')
    interval: float | None = Field(None, description='Check interval in seconds')
    dependencies: list[str] | None = Field(None, description='Dependencies checked')


class TraceFormat(Enum):
    json = 'json'
    text = 'text'
    compact = 'compact'
    pretty = 'pretty'


class DebugToolsSpec(ExtensionModel):
    repr_depth: conint(ge=1) | None = Field(
        None, description='Default __repr__ recursion depth'
    )
    sensitive_fields: list[str] | None = Field(
        None, description='Fields redacted in debug output'
    )
    trace_format: TraceFormat | None = Field(None, description='Trace output format')
    profiling_supported: bool | None = Field(
        None, description='Whether profiling hooks are available'
    )
    memory_tracking: bool | None = Field(
        None, description='Whether memory tracking is available'
    )
    async_debug: bool | None = Field(
        None, description='Whether async debugging tools are available'
    )


class ObservabilityLibraryFields(ExtensionModel):
    logging: LoggingSpec | None = None
    metrics: list[MetricSpec] | None = Field(
        None, description='Metrics exposed by the library'
    )
    tracing: TracingSpec | None = None
    health_checks: list[HealthCheckSpec] | None = Field(
        None, description='Health check endpoints'
    )
    debug_tools: DebugToolsSpec | None = None
